\hypertarget{simple__prefix__impl_8c}{\section{/\-Users/sidharthamani/huffman\-\_\-coder/src/simple\-\_\-prefix\-\_\-impl.c File Reference}
\label{simple__prefix__impl_8c}\index{/\-Users/sidharthamani/huffman\-\_\-coder/src/simple\-\_\-prefix\-\_\-impl.\-c@{/\-Users/sidharthamani/huffman\-\_\-coder/src/simple\-\_\-prefix\-\_\-impl.\-c}}
}


The implementation of \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree This file contains functions required to support the encoding and de-\/coding functions.\par
 Author \-: Sidhartha Mani\par
 Contact \-: \href{mailto:sidharthamn@gmail.com}{\tt sidharthamn@gmail.\-com} \par
 Last Updated \-: 23 Dec 2012 \par
  


{\ttfamily \#include \char`\"{}simple\-\_\-prefix\-\_\-impl.\-h\char`\"{}}\\*
Include dependency graph for simple\-\_\-prefix\-\_\-impl.\-c\-:
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structnode}{node} $\ast$ \hyperlink{simple__prefix__impl_8c_ad73cbefe8a90c459159ccc365eb3b33a}{init\-\_\-simple\-\_\-prefix} ()
\begin{DoxyCompactList}\small\item\em allocate memory for a new \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree \par
 {\bfseries Precondition\-:} The structure should not have already been allocated memory \par
 {\bfseries Postcondition\-:} Memory is allocated and returned to the calling environment \par
 \end{DoxyCompactList}\item 
\hyperlink{structnode}{node} $\ast$ \hyperlink{simple__prefix__impl_8c_a6657448982edc6daa25abcb440fca1d8}{construct\-\_\-simple\-\_\-prefix\-\_\-tree} (struct \hyperlink{structnode}{node} $\ast$root, char $\ast$input\-\_\-msgs, int size\-\_\-of\-\_\-input\-\_\-msgs)
\begin{DoxyCompactList}\small\item\em construct a naive \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree for a set of characters specified by input\-\_\-msgs \par
 {\bfseries  Precondition\-: } Root should have already been initialized \par
 {\bfseries  Postcondition\-: } The Root is initialized to a simple prefix tree for all printable characters \par
 \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8c_ab5bd0496da802122958e3af1482d1a6e}{simple\-\_\-prefix\-\_\-encode} (char $\ast$msg, int size\-\_\-of\-\_\-msg)
\begin{DoxyCompactList}\small\item\em encode a string based on the current \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree, size\-\_\-of\-\_\-msgs(param 2) should be specified in bytes\par
 {\bfseries Precondition \-:} The string into which the returned value should be captured should not have already been allocated. Right now, the function can only encode characters defined in L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S macro\par
 {\bfseries Postcondition \-:} The message is encoded according to the \hyperlink{structsimple__prefix}{simple\-\_\-prefix} algorithm and returned to the calling environment \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8c_a40ee92d324331ee4ca644e67d3697f58}{simple\-\_\-prefix\-\_\-decode} (char $\ast$encoded\-\_\-string, struct \hyperlink{structnode}{node} $\ast$root, int size\-\_\-of\-\_\-encoded\-\_\-string)
\begin{DoxyCompactList}\small\item\em decode an encoded string by using the prefix tree generated by construct\-\_\-simple\-\_\-prefix(struct node$\ast$, char$\ast$, int) The parameter 2 (struct node$\ast$ root) is a pointer to the generated tree.\par
 {\bfseries Precondition \-:} The tree should have already been generated. The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The encoded string is decoded and returned to the calling environment \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}{char2bits} (char $\ast$encoded\-\_\-string, int size\-\_\-of\-\_\-encoded\-\_\-string)
\begin{DoxyCompactList}\small\item\em convert encoded character array into bits for reducing storage space. Use this on an encoded string before persisting this in a file or wherever\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The binary representation of the encoded string is returned as an array of bytes(char) \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8c_adbcb96421197815cdb34df33d65839c8}{bits2char} (char $\ast$bit\-\_\-stream, int size\-\_\-of\-\_\-bit\-\_\-stream)
\begin{DoxyCompactList}\small\item\em convert encoded bits(as binary data) into a character array for decoding. Use this whenever you read from a persisted source.\-simple\-\_\-prefix\-\_\-decode(char$\ast$, struct node$\ast$, int) undersands encoded strings in char format, not actual binary. Lots of improvement required in this function. Right now, it can only work with the constraint of encoded string length being a multiple of 8.\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The character representation of the encoded binary string is returned as an array of bytes(char) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The implementation of \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree This file contains functions required to support the encoding and de-\/coding functions.\par
 Author \-: Sidhartha Mani\par
 Contact \-: \href{mailto:sidharthamn@gmail.com}{\tt sidharthamn@gmail.\-com} \par
 Last Updated \-: 23 Dec 2012 \par
 

\subsection{Function Documentation}
\hypertarget{simple__prefix__impl_8c_adbcb96421197815cdb34df33d65839c8}{\index{simple\-\_\-prefix\-\_\-impl.\-c@{simple\-\_\-prefix\-\_\-impl.\-c}!bits2char@{bits2char}}
\index{bits2char@{bits2char}!simple_prefix_impl.c@{simple\-\_\-prefix\-\_\-impl.\-c}}
\subsubsection[{bits2char}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ bits2char (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{bit\-\_\-stream, }
\item[{int}]{size\-\_\-of\-\_\-bit\-\_\-stream}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8c_adbcb96421197815cdb34df33d65839c8}


convert encoded bits(as binary data) into a character array for decoding. Use this whenever you read from a persisted source.\-simple\-\_\-prefix\-\_\-decode(char$\ast$, struct node$\ast$, int) undersands encoded strings in char format, not actual binary. Lots of improvement required in this function. Right now, it can only work with the constraint of encoded string length being a multiple of 8.\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The character representation of the encoded binary string is returned as an array of bytes(char) 

/fn char$\ast$ \hyperlink{simple__prefix__impl_8c_adbcb96421197815cdb34df33d65839c8}{bits2char(char$\ast$ bit\-\_\-stream, int size\-\_\-of\-\_\-bit\-\_\-stream)} 
\begin{DoxyParams}{Parameters}
{\em bit\-\_\-stream} & bit stream containing the binary encoded information \\
\hline
{\em size\-\_\-of\-\_\-bit\-\_\-stream} & size of the bit\-\_\-stream \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an array of bytes(char) containing each bit of param 1(bit\-\_\-stream) as a character, as required by \hyperlink{simple__prefix__impl_8c_a40ee92d324331ee4ca644e67d3697f58}{simple\-\_\-prefix\-\_\-decode(char$\ast$, struct node$\ast$, int)} 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} *encoded\_string = (\textcolor{keywordtype}{char} *)malloc(strlen(bit\_stream)*8 + 1);
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{int} j = 0;
    \textcolor{keywordtype}{int} k = size\_of\_bit\_stream*8 - 1;
    encoded\_string[k+1] = \textcolor{charliteral}{'\(\backslash\)0'};
    \textcolor{keywordtype}{char} bit;
    \textcolor{keywordflow}{for}(i = 0;i<size\_of\_bit\_stream;i++)
    \{
        bit = bit\_stream[i];
        \textcolor{keywordflow}{for} (j=0; j<8; j++) 
        \{
            \textcolor{keywordflow}{if} (bit & 1) 
            \{
                encoded\_string[k--] = \textcolor{charliteral}{'1'};
            \}
            \textcolor{keywordflow}{else} 
            \{
                encoded\_string[k--] = \textcolor{charliteral}{'0'};
            \}
            bit >>= 1;
        \}
    \}
    \textcolor{keywordflow}{return} encoded\_string;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}{\index{simple\-\_\-prefix\-\_\-impl.\-c@{simple\-\_\-prefix\-\_\-impl.\-c}!char2bits@{char2bits}}
\index{char2bits@{char2bits}!simple_prefix_impl.c@{simple\-\_\-prefix\-\_\-impl.\-c}}
\subsubsection[{char2bits}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ char2bits (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{encoded\-\_\-string, }
\item[{int}]{size\-\_\-of\-\_\-encoded\-\_\-string}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}


convert encoded character array into bits for reducing storage space. Use this on an encoded string before persisting this in a file or wherever\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The binary representation of the encoded string is returned as an array of bytes(char) 

/fn char$\ast$ \hyperlink{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}{char2bits(char$\ast$ encoded\-\_\-string, int size\-\_\-of\-\_\-encoded\-\_\-string)} 
\begin{DoxyParams}{Parameters}
{\em encoded\-\_\-string} & The string to be converted into binary \\
\hline
{\em size\-\_\-of\-\_\-encoded\-\_\-string} & the size of the string in param 1 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a bit stream containing the binary information encoded in param 1(encoded\-\_\-string) 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} *bit\_stream = (\textcolor{keywordtype}{char} *)malloc(size\_of\_encoded\_string/8 + 2);
    \textcolor{keywordtype}{char} bit = 0;
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{int} j = 0;
    \textcolor{keywordflow}{for} (i=0; i<size\_of\_encoded\_string; i++) 
    \{
        bit |= (int)((\textcolor{keywordtype}{int})encoded\_string[i] - (int)\textcolor{charliteral}{'0'});
        \textcolor{keywordflow}{if} ((i+1)%8 == 0) 
        \{
            bit\_stream[j++] = bit;
            bit = 0;
        \}
        bit <<= 1;
    \}
    \textcolor{keywordflow}{return} bit\_stream;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8c_a6657448982edc6daa25abcb440fca1d8}{\index{simple\-\_\-prefix\-\_\-impl.\-c@{simple\-\_\-prefix\-\_\-impl.\-c}!construct\-\_\-simple\-\_\-prefix\-\_\-tree@{construct\-\_\-simple\-\_\-prefix\-\_\-tree}}
\index{construct\-\_\-simple\-\_\-prefix\-\_\-tree@{construct\-\_\-simple\-\_\-prefix\-\_\-tree}!simple_prefix_impl.c@{simple\-\_\-prefix\-\_\-impl.\-c}}
\subsubsection[{construct\-\_\-simple\-\_\-prefix\-\_\-tree}]{\setlength{\rightskip}{0pt plus 5cm}{\bf node}$\ast$ construct\-\_\-simple\-\_\-prefix\-\_\-tree (
\begin{DoxyParamCaption}
\item[{struct {\bf node} $\ast$}]{root, }
\item[{char $\ast$}]{input\-\_\-msgs, }
\item[{int}]{size\-\_\-of\-\_\-input\-\_\-msgs}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8c_a6657448982edc6daa25abcb440fca1d8}


construct a naive \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree for a set of characters specified by input\-\_\-msgs \par
 {\bfseries  Precondition\-: } Root should have already been initialized \par
 {\bfseries  Postcondition\-: } The Root is initialized to a simple prefix tree for all printable characters \par
 


\begin{DoxyParams}{Parameters}
{\em root} & A pointer to the root of the tree. It is essentially a pointer to the entire tree. \\
\hline
{\em input\-\_\-msgs} & An array of characters for which the tree is being built. \par
 {\bfseries Note \-:} The letters that occur earlier in the input\-\_\-msgs array will have a lower encoded length than the letters that occur later in the input\-\_\-msgs array. \\
\hline
{\em size\-\_\-of\-\_\-input\-\_\-msgs} & The length of the input\-\_\-msgs array. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keyword}{struct }\hyperlink{structnode}{node} *temp =  root;
    \textcolor{keywordflow}{for} (i = 0; i<size\_of\_input\_msgs; i++) 
    \{
        \textcolor{keywordflow}{while} (temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} != NULL) 
        \{
            temp = temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node};
        \}
        \textcolor{keywordflow}{if} (temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} == NULL && temp == root) 
        \{
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct}
       \hyperlink{structnode}{node}));
            new\_node->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = input\_msgs[i];
            temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = new\_node;
            new\_node->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
            new\_node->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
        \}
        \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} == NULL && temp == root) 
        \{
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct}
       \hyperlink{structnode}{node}));
            new\_node->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = input\_msgs[i];
            temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = new\_node;
            new\_node->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
            new\_node->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
        \}
        \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} == NULL)
        \{
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct}
       \hyperlink{structnode}{node}));
            new\_node->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = temp->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg};
            temp->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 0;
            temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = new\_node;
            new\_node->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
            new\_node->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node\_2 = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{
      struct} \hyperlink{structnode}{node}));
            temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = new\_node\_2;
            new\_node\_2->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = input\_msgs[i];
            new\_node\_2->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
            new\_node\_2->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node\_2->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
        \}
    \}
    \textcolor{keywordflow}{return} root;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8c_ad73cbefe8a90c459159ccc365eb3b33a}{\index{simple\-\_\-prefix\-\_\-impl.\-c@{simple\-\_\-prefix\-\_\-impl.\-c}!init\-\_\-simple\-\_\-prefix@{init\-\_\-simple\-\_\-prefix}}
\index{init\-\_\-simple\-\_\-prefix@{init\-\_\-simple\-\_\-prefix}!simple_prefix_impl.c@{simple\-\_\-prefix\-\_\-impl.\-c}}
\subsubsection[{init\-\_\-simple\-\_\-prefix}]{\setlength{\rightskip}{0pt plus 5cm}{\bf node}$\ast$ init\-\_\-simple\-\_\-prefix (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8c_ad73cbefe8a90c459159ccc365eb3b33a}


allocate memory for a new \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree \par
 {\bfseries Precondition\-:} The structure should not have already been allocated memory \par
 {\bfseries Postcondition\-:} Memory is allocated and returned to the calling environment \par
 

\begin{DoxyReturn}{Returns}
A pointer to the allocated memory 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keyword}{struct }\hyperlink{structnode}{node} *root = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structnode}{node}));
    root->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 0;
    root->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
    root->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
    \textcolor{keywordflow}{return} root;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8c_a40ee92d324331ee4ca644e67d3697f58}{\index{simple\-\_\-prefix\-\_\-impl.\-c@{simple\-\_\-prefix\-\_\-impl.\-c}!simple\-\_\-prefix\-\_\-decode@{simple\-\_\-prefix\-\_\-decode}}
\index{simple\-\_\-prefix\-\_\-decode@{simple\-\_\-prefix\-\_\-decode}!simple_prefix_impl.c@{simple\-\_\-prefix\-\_\-impl.\-c}}
\subsubsection[{simple\-\_\-prefix\-\_\-decode}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ simple\-\_\-prefix\-\_\-decode (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{encoded\-\_\-string, }
\item[{struct {\bf node} $\ast$}]{root, }
\item[{int}]{size\-\_\-of\-\_\-encoded\-\_\-string}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8c_a40ee92d324331ee4ca644e67d3697f58}


decode an encoded string by using the prefix tree generated by construct\-\_\-simple\-\_\-prefix(struct node$\ast$, char$\ast$, int) The parameter 2 (struct node$\ast$ root) is a pointer to the generated tree.\par
 {\bfseries Precondition \-:} The tree should have already been generated. The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The encoded string is decoded and returned to the calling environment 


\begin{DoxyParams}{Parameters}
{\em encoded\-\_\-string} & the encoded string as an array of characters, not as binary data \\
\hline
{\em root} & the \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree needed by the decoding algorithm \\
\hline
{\em size\-\_\-of\-\_\-encoded\-\_\-string} & the size of the encoded string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the decoded string 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} *decoded\_string = (\textcolor{keywordtype}{char} *)malloc(size\_of\_encoded\_string);
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{int} j = 0;
    \textcolor{keyword}{struct }\hyperlink{structnode}{node} *temp;
    \textcolor{keywordflow}{while}(i < size\_of\_encoded\_string)
    \{
        \textcolor{comment}{//iterate through each node until you reach the encoded character}
        temp = root;
        \textcolor{keywordflow}{while}(temp->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} != 1 && i < size\_of\_encoded\_string)
        \{
            \textcolor{keywordflow}{if}(encoded\_string[i] == \textcolor{charliteral}{'0'})
            \{
                temp = temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node};
            \}
            \textcolor{keywordflow}{else}
            \{
                temp = temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node};
            \}
            i++;
        \}
        decoded\_string[j++] = temp->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg};
    \}
    \textcolor{comment}{//finish the string}
    decoded\_string[j] = \textcolor{charliteral}{'\(\backslash\)0'};
    \textcolor{keywordflow}{return} decoded\_string;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8c_ab5bd0496da802122958e3af1482d1a6e}{\index{simple\-\_\-prefix\-\_\-impl.\-c@{simple\-\_\-prefix\-\_\-impl.\-c}!simple\-\_\-prefix\-\_\-encode@{simple\-\_\-prefix\-\_\-encode}}
\index{simple\-\_\-prefix\-\_\-encode@{simple\-\_\-prefix\-\_\-encode}!simple_prefix_impl.c@{simple\-\_\-prefix\-\_\-impl.\-c}}
\subsubsection[{simple\-\_\-prefix\-\_\-encode}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ simple\-\_\-prefix\-\_\-encode (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{msg, }
\item[{int}]{size\-\_\-of\-\_\-msg}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8c_ab5bd0496da802122958e3af1482d1a6e}


encode a string based on the current \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree, size\-\_\-of\-\_\-msgs(param 2) should be specified in bytes\par
 {\bfseries Precondition \-:} The string into which the returned value should be captured should not have already been allocated. Right now, the function can only encode characters defined in L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S macro\par
 {\bfseries Postcondition \-:} The message is encoded according to the \hyperlink{structsimple__prefix}{simple\-\_\-prefix} algorithm and returned to the calling environment 


\begin{DoxyParams}{Parameters}
{\em msg} & the string that needs to be encoded \\
\hline
{\em size\-\_\-of\-\_\-msg} & the length of the message \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the encoded message. \par
 The returned encoded message is not in binary, it is still a character array. It can be converted into binary using \hyperlink{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}{char2bits(char $\ast$, int)} function 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} conversion\_tree[][27] = \{
        \textcolor{stringliteral}{"1"}, \textcolor{comment}{//e}
        \textcolor{stringliteral}{"01"}, \textcolor{comment}{//a}
        \textcolor{stringliteral}{"001"}, \textcolor{comment}{//r}
        \textcolor{stringliteral}{"0001"}, \textcolor{comment}{//i}
        \textcolor{stringliteral}{"00001"}, \textcolor{comment}{//o}
        \textcolor{stringliteral}{"000001"}, \textcolor{comment}{//t}
        \textcolor{stringliteral}{"0000001"}, \textcolor{comment}{//n}
        \textcolor{stringliteral}{"00000001"}, \textcolor{comment}{//s}
        \textcolor{stringliteral}{"000000001"}, \textcolor{comment}{//l}
        \textcolor{stringliteral}{"0000000001"}, \textcolor{comment}{//c}
        \textcolor{stringliteral}{"00000000001"}, \textcolor{comment}{//u}
        \textcolor{stringliteral}{"000000000001"}, \textcolor{comment}{//d}
        \textcolor{stringliteral}{"0000000000001"}, \textcolor{comment}{//p}
        \textcolor{stringliteral}{"00000000000001"}, \textcolor{comment}{//m}
        \textcolor{stringliteral}{"000000000000001"}, \textcolor{comment}{//h}
        \textcolor{stringliteral}{"0000000000000001"}, \textcolor{comment}{//g}
        \textcolor{stringliteral}{"00000000000000001"}, \textcolor{comment}{//b}
        \textcolor{stringliteral}{"000000000000000001"}, \textcolor{comment}{//f}
        \textcolor{stringliteral}{"0000000000000000001"}, \textcolor{comment}{//y}
        \textcolor{stringliteral}{"00000000000000000001"}, \textcolor{comment}{//w}
        \textcolor{stringliteral}{"000000000000000000001"}, \textcolor{comment}{//k}
        \textcolor{stringliteral}{"0000000000000000000001"}, \textcolor{comment}{//v}
        \textcolor{stringliteral}{"00000000000000000000001"}, \textcolor{comment}{//x}
        \textcolor{stringliteral}{"000000000000000000000001"}, \textcolor{comment}{//z}
        \textcolor{stringliteral}{"0000000000000000000000001"}, \textcolor{comment}{//j}
        \textcolor{stringliteral}{"00000000000000000000000001"}, \textcolor{comment}{//q}
        \textcolor{stringliteral}{"00000000000000000000000000"} \textcolor{comment}{//WHITE SPACE}
    \};
    \textcolor{keywordtype}{char} *encoded\_string = (\textcolor{keywordtype}{char} *)malloc(27*size\_of\_msg);
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{char} reference\_string[] = \hyperlink{simple__prefix__impl_8h_a94747a3d988297667d1f086be19a7f3d}{LOWER\_CASE\_ALPHABETS};
    \textcolor{keywordflow}{while} (i < size\_of\_msg) 
    \{
    \textcolor{comment}{//ignore un-recognized characters}
    \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})((strchr(reference\_string,\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg}[i])) - reference\_string) < 0 || (
      int)((strchr(reference\_string,\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg}[i])) - reference\_string) > 26) \{
        i++;
        \textcolor{keywordflow}{continue};
    \}
    encoded\_string = strcat(encoded\_string,conversion\_tree[(\textcolor{keywordtype}{int})((strchr(
      reference\_string,\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg}[i])) - reference\_string)]);
    i++;
    \}
    \textcolor{keywordflow}{return} encoded\_string;
\}
\end{DoxyCode}
