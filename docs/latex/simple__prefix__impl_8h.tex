\hypertarget{simple__prefix__impl_8h}{\section{/\-Users/sidharthamani/huffman\-\_\-coder/include/simple\-\_\-prefix\-\_\-impl.h File Reference}
\label{simple__prefix__impl_8h}\index{/\-Users/sidharthamani/huffman\-\_\-coder/include/simple\-\_\-prefix\-\_\-impl.\-h@{/\-Users/sidharthamani/huffman\-\_\-coder/include/simple\-\_\-prefix\-\_\-impl.\-h}}
}
{\ttfamily \#include $<$stdio.\-h$>$}\\*
{\ttfamily \#include $<$stdlib.\-h$>$}\\*
{\ttfamily \#include $<$string.\-h$>$}\\*
Include dependency graph for simple\-\_\-prefix\-\_\-impl.\-h\-:
This graph shows which files directly or indirectly include this file\-:
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structnode}{node}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{simple__prefix__impl_8h_a94747a3d988297667d1f086be19a7f3d}{L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}~\char`\"{}eariotnslcudpmhgbfywkvxzjq \char`\"{}
\item 
\#define \hyperlink{simple__prefix__impl_8h_aa462b833c678d200d3a76f3dc16d415c}{U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}~\char`\"{}A\-B\-C\-D\-E\-F\-G\-H\-I\-J\-K\-L\-M\-N\-O\-P\-Q\-R\-S\-T\-U\-V\-W\-X\-Y\-Z\char`\"{}
\item 
\#define \hyperlink{simple__prefix__impl_8h_a52c6eed29863def7303121b65975e83b}{N\-U\-M\-B\-E\-R\-S}~\char`\"{}0123456789\char`\"{}
\item 
\#define \hyperlink{simple__prefix__impl_8h_aca3321d60a25310d108cb125e8e639e0}{W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E}~\char`\"{} \char`\"{}
\item 
\#define \hyperlink{simple__prefix__impl_8h_a7b99dc1e1c86b4897498c2d436ead1b5}{N\-E\-W\-\_\-\-L\-I\-N\-E}~\char`\"{}\textbackslash{}n\char`\"{}
\item 
\#define \hyperlink{simple__prefix__impl_8h_af281425e62298bac2df0fbe8690a4844}{P\-E\-R\-I\-O\-D}~\char`\"{}.\char`\"{}
\item 
\#define \hyperlink{simple__prefix__impl_8h_aa2f49001be13949a16a57e6c99ab00ad}{C\-O\-M\-M\-A}~\char`\"{},\char`\"{}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structnode}{node} \hyperlink{simple__prefix__impl_8h_af4aeda155dbe167f1c1cf38cb65bf324}{node}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structnode}{node} $\ast$ \hyperlink{simple__prefix__impl_8h_af8da3d9dd76b4948b2233ed801729904}{init\-\_\-simple\-\_\-prefix} ()
\begin{DoxyCompactList}\small\item\em allocate memory for a new \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree \par
 {\bfseries Precondition\-:} The structure should not have already been allocated memory \par
 {\bfseries Postcondition\-:} Memory is allocated and returned to the calling environment \par
 \end{DoxyCompactList}\item 
\hyperlink{structnode}{node} $\ast$ \hyperlink{simple__prefix__impl_8h_a2803bf8d5b507d080053c5795f1f2e8e}{construct\-\_\-simple\-\_\-prefix\-\_\-tree} (struct \hyperlink{structnode}{node} $\ast$root, char $\ast$input\-\_\-msgs, int size\-\_\-of\-\_\-input\-\_\-msgs)
\begin{DoxyCompactList}\small\item\em construct a naive \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree for a set of characters specified by input\-\_\-msgs \par
 {\bfseries  Precondition\-: } Root should have already been initialized \par
 {\bfseries  Postcondition\-: } The Root is initialized to a simple prefix tree for all printable characters \par
 \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8h_a1d974ca63f3322d8a7d444c6ebbf6212}{simple\-\_\-prefix\-\_\-encode} (char $\ast$msg, int size\-\_\-of\-\_\-msg)
\begin{DoxyCompactList}\small\item\em encode a string based on the current \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree, size\-\_\-of\-\_\-msgs(param 2) should be specified in bytes\par
 {\bfseries Precondition \-:} The string into which the returned value should be captured should not have already been allocated. Right now, the function can only encode characters defined in L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S macro\par
 {\bfseries Postcondition \-:} The message is encoded according to the \hyperlink{structsimple__prefix}{simple\-\_\-prefix} algorithm and returned to the calling environment \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8h_a01c7baaef3398c045f127558eeef0b14}{simple\-\_\-prefix\-\_\-decode} (char $\ast$encoded\-\_\-string, struct \hyperlink{structnode}{node} $\ast$root, int size\-\_\-of\-\_\-encoded\-\_\-string)
\begin{DoxyCompactList}\small\item\em decode an encoded string by using the prefix tree generated by construct\-\_\-simple\-\_\-prefix(struct node$\ast$, char$\ast$, int) The parameter 2 (struct node$\ast$ root) is a pointer to the generated tree.\par
 {\bfseries Precondition \-:} The tree should have already been generated. The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The encoded string is decoded and returned to the calling environment \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8h_ac7b35ccc6d71b9a01d2ab3609e20e698}{char2bits} (char $\ast$encoded\-\_\-string, int size\-\_\-of\-\_\-encoded\-\_\-string)
\begin{DoxyCompactList}\small\item\em convert encoded character array into bits for reducing storage space. Use this on an encoded string before persisting this in a file or wherever\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The binary representation of the encoded string is returned as an array of bytes(char) \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{simple__prefix__impl_8h_adbcb96421197815cdb34df33d65839c8}{bits2char} (char $\ast$bit\-\_\-stream, int size\-\_\-of\-\_\-bit\-\_\-stream)
\begin{DoxyCompactList}\small\item\em convert encoded bits(as binary data) into a character array for decoding. Use this whenever you read from a persisted source.\-simple\-\_\-prefix\-\_\-decode(char$\ast$, struct node$\ast$, int) undersands encoded strings in char format, not actual binary. Lots of improvement required in this function. Right now, it can only work with the constraint of encoded string length being a multiple of 8.\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The character representation of the encoded binary string is returned as an array of bytes(char) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\hypertarget{simple__prefix__impl_8h_aa2f49001be13949a16a57e6c99ab00ad}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!C\-O\-M\-M\-A@{C\-O\-M\-M\-A}}
\index{C\-O\-M\-M\-A@{C\-O\-M\-M\-A}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{C\-O\-M\-M\-A}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\-O\-M\-M\-A~\char`\"{},\char`\"{}}}\label{simple__prefix__impl_8h_aa2f49001be13949a16a57e6c99ab00ad}
\hypertarget{simple__prefix__impl_8h_a94747a3d988297667d1f086be19a7f3d}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S@{L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}}
\index{L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S@{L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S~\char`\"{}eariotnslcudpmhgbfywkvxzjq \char`\"{}}}\label{simple__prefix__impl_8h_a94747a3d988297667d1f086be19a7f3d}
\hypertarget{simple__prefix__impl_8h_a7b99dc1e1c86b4897498c2d436ead1b5}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!N\-E\-W\-\_\-\-L\-I\-N\-E@{N\-E\-W\-\_\-\-L\-I\-N\-E}}
\index{N\-E\-W\-\_\-\-L\-I\-N\-E@{N\-E\-W\-\_\-\-L\-I\-N\-E}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{N\-E\-W\-\_\-\-L\-I\-N\-E}]{\setlength{\rightskip}{0pt plus 5cm}\#define N\-E\-W\-\_\-\-L\-I\-N\-E~\char`\"{}\textbackslash{}n\char`\"{}}}\label{simple__prefix__impl_8h_a7b99dc1e1c86b4897498c2d436ead1b5}
\hypertarget{simple__prefix__impl_8h_a52c6eed29863def7303121b65975e83b}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!N\-U\-M\-B\-E\-R\-S@{N\-U\-M\-B\-E\-R\-S}}
\index{N\-U\-M\-B\-E\-R\-S@{N\-U\-M\-B\-E\-R\-S}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{N\-U\-M\-B\-E\-R\-S}]{\setlength{\rightskip}{0pt plus 5cm}\#define N\-U\-M\-B\-E\-R\-S~\char`\"{}0123456789\char`\"{}}}\label{simple__prefix__impl_8h_a52c6eed29863def7303121b65975e83b}
\hypertarget{simple__prefix__impl_8h_af281425e62298bac2df0fbe8690a4844}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!P\-E\-R\-I\-O\-D@{P\-E\-R\-I\-O\-D}}
\index{P\-E\-R\-I\-O\-D@{P\-E\-R\-I\-O\-D}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{P\-E\-R\-I\-O\-D}]{\setlength{\rightskip}{0pt plus 5cm}\#define P\-E\-R\-I\-O\-D~\char`\"{}.\char`\"{}}}\label{simple__prefix__impl_8h_af281425e62298bac2df0fbe8690a4844}
\hypertarget{simple__prefix__impl_8h_aa462b833c678d200d3a76f3dc16d415c}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S@{U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}}
\index{U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S@{U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S}]{\setlength{\rightskip}{0pt plus 5cm}\#define U\-P\-P\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S~\char`\"{}A\-B\-C\-D\-E\-F\-G\-H\-I\-J\-K\-L\-M\-N\-O\-P\-Q\-R\-S\-T\-U\-V\-W\-X\-Y\-Z\char`\"{}}}\label{simple__prefix__impl_8h_aa462b833c678d200d3a76f3dc16d415c}
\hypertarget{simple__prefix__impl_8h_aca3321d60a25310d108cb125e8e639e0}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E@{W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E}}
\index{W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E@{W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E}]{\setlength{\rightskip}{0pt plus 5cm}\#define W\-H\-I\-T\-E\-\_\-\-S\-P\-A\-C\-E~\char`\"{} \char`\"{}}}\label{simple__prefix__impl_8h_aca3321d60a25310d108cb125e8e639e0}


\subsection{Typedef Documentation}
\hypertarget{simple__prefix__impl_8h_af4aeda155dbe167f1c1cf38cb65bf324}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!node@{node}}
\index{node@{node}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{node}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf node} {\bf node}}}\label{simple__prefix__impl_8h_af4aeda155dbe167f1c1cf38cb65bf324}


\subsection{Function Documentation}
\hypertarget{simple__prefix__impl_8h_adbcb96421197815cdb34df33d65839c8}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!bits2char@{bits2char}}
\index{bits2char@{bits2char}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{bits2char}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ bits2char (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{bit\-\_\-stream, }
\item[{int}]{size\-\_\-of\-\_\-bit\-\_\-stream}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8h_adbcb96421197815cdb34df33d65839c8}


convert encoded bits(as binary data) into a character array for decoding. Use this whenever you read from a persisted source.\-simple\-\_\-prefix\-\_\-decode(char$\ast$, struct node$\ast$, int) undersands encoded strings in char format, not actual binary. Lots of improvement required in this function. Right now, it can only work with the constraint of encoded string length being a multiple of 8.\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The character representation of the encoded binary string is returned as an array of bytes(char) 

/fn char$\ast$ \hyperlink{simple__prefix__impl_8c_adbcb96421197815cdb34df33d65839c8}{bits2char(char$\ast$ bit\-\_\-stream, int size\-\_\-of\-\_\-bit\-\_\-stream)} 
\begin{DoxyParams}{Parameters}
{\em bit\-\_\-stream} & bit stream containing the binary encoded information \\
\hline
{\em size\-\_\-of\-\_\-bit\-\_\-stream} & size of the bit\-\_\-stream \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an array of bytes(char) containing each bit of param 1(bit\-\_\-stream) as a character, as required by \hyperlink{simple__prefix__impl_8c_a40ee92d324331ee4ca644e67d3697f58}{simple\-\_\-prefix\-\_\-decode(char$\ast$, struct node$\ast$, int)} 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} *encoded\_string = (\textcolor{keywordtype}{char} *)malloc(strlen(bit\_stream)*8 + 1);
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{int} j = 0;
    \textcolor{keywordtype}{int} k = size\_of\_bit\_stream*8 - 1;
    encoded\_string[k+1] = \textcolor{charliteral}{'\(\backslash\)0'};
    \textcolor{keywordtype}{char} bit;
    \textcolor{keywordflow}{for}(i = 0;i<size\_of\_bit\_stream;i++)
    \{
        bit = bit\_stream[i];
        \textcolor{keywordflow}{for} (j=0; j<8; j++) 
        \{
            \textcolor{keywordflow}{if} (bit & 1) 
            \{
                encoded\_string[k--] = \textcolor{charliteral}{'1'};
            \}
            \textcolor{keywordflow}{else} 
            \{
                encoded\_string[k--] = \textcolor{charliteral}{'0'};
            \}
            bit >>= 1;
        \}
    \}
    \textcolor{keywordflow}{return} encoded\_string;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8h_ac7b35ccc6d71b9a01d2ab3609e20e698}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!char2bits@{char2bits}}
\index{char2bits@{char2bits}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{char2bits}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ char2bits (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{encoded\-\_\-string, }
\item[{int}]{size\-\_\-of\-\_\-encoded\-\_\-string}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8h_ac7b35ccc6d71b9a01d2ab3609e20e698}


convert encoded character array into bits for reducing storage space. Use this on an encoded string before persisting this in a file or wherever\par
 {\bfseries Precondition \-:} The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The binary representation of the encoded string is returned as an array of bytes(char) 

/fn char$\ast$ \hyperlink{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}{char2bits(char$\ast$ encoded\-\_\-string, int size\-\_\-of\-\_\-encoded\-\_\-string)} 
\begin{DoxyParams}{Parameters}
{\em encoded\-\_\-string} & The string to be converted into binary \\
\hline
{\em size\-\_\-of\-\_\-encoded\-\_\-string} & the size of the string in param 1 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a bit stream containing the binary information encoded in param 1(encoded\-\_\-string) 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} *bit\_stream = (\textcolor{keywordtype}{char} *)malloc(size\_of\_encoded\_string/8 + 2);
    \textcolor{keywordtype}{char} bit = 0;
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{int} j = 0;
    \textcolor{keywordflow}{for} (i=0; i<size\_of\_encoded\_string; i++) 
    \{
        bit |= (int)((\textcolor{keywordtype}{int})encoded\_string[i] - (int)\textcolor{charliteral}{'0'});
        \textcolor{keywordflow}{if} ((i+1)%8 == 0) 
        \{
            bit\_stream[j++] = bit;
            bit = 0;
        \}
        bit <<= 1;
    \}
    \textcolor{keywordflow}{return} bit\_stream;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8h_a2803bf8d5b507d080053c5795f1f2e8e}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!construct\-\_\-simple\-\_\-prefix\-\_\-tree@{construct\-\_\-simple\-\_\-prefix\-\_\-tree}}
\index{construct\-\_\-simple\-\_\-prefix\-\_\-tree@{construct\-\_\-simple\-\_\-prefix\-\_\-tree}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{construct\-\_\-simple\-\_\-prefix\-\_\-tree}]{\setlength{\rightskip}{0pt plus 5cm}{\bf node} $\ast$ construct\-\_\-simple\-\_\-prefix\-\_\-tree (
\begin{DoxyParamCaption}
\item[{struct {\bf node} $\ast$}]{root, }
\item[{char $\ast$}]{input\-\_\-msgs, }
\item[{int}]{size\-\_\-of\-\_\-input\-\_\-msgs}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8h_a2803bf8d5b507d080053c5795f1f2e8e}


construct a naive \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree for a set of characters specified by input\-\_\-msgs \par
 {\bfseries  Precondition\-: } Root should have already been initialized \par
 {\bfseries  Postcondition\-: } The Root is initialized to a simple prefix tree for all printable characters \par
 


\begin{DoxyParams}{Parameters}
{\em root} & A pointer to the root of the tree. It is essentially a pointer to the entire tree. \\
\hline
{\em input\-\_\-msgs} & An array of characters for which the tree is being built. \par
 {\bfseries Note \-:} The letters that occur earlier in the input\-\_\-msgs array will have a lower encoded length than the letters that occur later in the input\-\_\-msgs array. \\
\hline
{\em size\-\_\-of\-\_\-input\-\_\-msgs} & The length of the input\-\_\-msgs array. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keyword}{struct }\hyperlink{structnode}{node} *temp =  root;
    \textcolor{keywordflow}{for} (i = 0; i<size\_of\_input\_msgs; i++) 
    \{
        \textcolor{keywordflow}{while} (temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} != NULL) 
        \{
            temp = temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node};
        \}
        \textcolor{keywordflow}{if} (temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} == NULL && temp == root) 
        \{
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct}
       \hyperlink{structnode}{node}));
            new\_node->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = input\_msgs[i];
            temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = new\_node;
            new\_node->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
            new\_node->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
        \}
        \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} == NULL && temp == root) 
        \{
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct}
       \hyperlink{structnode}{node}));
            new\_node->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = input\_msgs[i];
            temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = new\_node;
            new\_node->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
            new\_node->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
        \}
        \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} == NULL)
        \{
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct}
       \hyperlink{structnode}{node}));
            new\_node->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = temp->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg};
            temp->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 0;
            temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = new\_node;
            new\_node->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
            new\_node->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
            \textcolor{keyword}{struct }\hyperlink{structnode}{node} *new\_node\_2 = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{
      struct} \hyperlink{structnode}{node}));
            temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = new\_node\_2;
            new\_node\_2->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg} = input\_msgs[i];
            new\_node\_2->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 1;
            new\_node\_2->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
            new\_node\_2->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
        \}
    \}
    \textcolor{keywordflow}{return} root;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8h_af8da3d9dd76b4948b2233ed801729904}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!init\-\_\-simple\-\_\-prefix@{init\-\_\-simple\-\_\-prefix}}
\index{init\-\_\-simple\-\_\-prefix@{init\-\_\-simple\-\_\-prefix}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{init\-\_\-simple\-\_\-prefix}]{\setlength{\rightskip}{0pt plus 5cm}{\bf node} $\ast$ init\-\_\-simple\-\_\-prefix (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8h_af8da3d9dd76b4948b2233ed801729904}


allocate memory for a new \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree \par
 {\bfseries Precondition\-:} The structure should not have already been allocated memory \par
 {\bfseries Postcondition\-:} Memory is allocated and returned to the calling environment \par
 

\begin{DoxyReturn}{Returns}
A pointer to the allocated memory 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keyword}{struct }\hyperlink{structnode}{node} *root = (\textcolor{keyword}{struct }\hyperlink{structnode}{node} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structnode}{node}));
    root->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} = 0;
    root->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node} = NULL;
    root->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node} = NULL;
    \textcolor{keywordflow}{return} root;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8h_a01c7baaef3398c045f127558eeef0b14}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!simple\-\_\-prefix\-\_\-decode@{simple\-\_\-prefix\-\_\-decode}}
\index{simple\-\_\-prefix\-\_\-decode@{simple\-\_\-prefix\-\_\-decode}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{simple\-\_\-prefix\-\_\-decode}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ simple\-\_\-prefix\-\_\-decode (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{encoded\-\_\-string, }
\item[{struct {\bf node} $\ast$}]{root, }
\item[{int}]{size\-\_\-of\-\_\-encoded\-\_\-string}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8h_a01c7baaef3398c045f127558eeef0b14}


decode an encoded string by using the prefix tree generated by construct\-\_\-simple\-\_\-prefix(struct node$\ast$, char$\ast$, int) The parameter 2 (struct node$\ast$ root) is a pointer to the generated tree.\par
 {\bfseries Precondition \-:} The tree should have already been generated. The string capturing the return value should not have already been allocated memory\par
 {\bfseries Postcondition \-:} The encoded string is decoded and returned to the calling environment 


\begin{DoxyParams}{Parameters}
{\em encoded\-\_\-string} & the encoded string as an array of characters, not as binary data \\
\hline
{\em root} & the \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree needed by the decoding algorithm \\
\hline
{\em size\-\_\-of\-\_\-encoded\-\_\-string} & the size of the encoded string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the decoded string 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} *decoded\_string = (\textcolor{keywordtype}{char} *)malloc(size\_of\_encoded\_string);
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{int} j = 0;
    \textcolor{keyword}{struct }\hyperlink{structnode}{node} *temp;
    \textcolor{keywordflow}{while}(i < size\_of\_encoded\_string)
    \{
        \textcolor{comment}{//iterate through each node until you reach the encoded character}
        temp = root;
        \textcolor{keywordflow}{while}(temp->\hyperlink{structnode_ad066657fe1374fb9852c285175a3774f}{is\_leaf} != 1 && i < size\_of\_encoded\_string)
        \{
            \textcolor{keywordflow}{if}(encoded\_string[i] == \textcolor{charliteral}{'0'})
            \{
                temp = temp->\hyperlink{structnode_a43dd3cf499d5b2270fcfbb29eb0a0d66}{left\_node};
            \}
            \textcolor{keywordflow}{else}
            \{
                temp = temp->\hyperlink{structnode_af729d9e66cefdd8c0a114cb0da5f7b7c}{right\_node};
            \}
            i++;
        \}
        decoded\_string[j++] = temp->\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg};
    \}
    \textcolor{comment}{//finish the string}
    decoded\_string[j] = \textcolor{charliteral}{'\(\backslash\)0'};
    \textcolor{keywordflow}{return} decoded\_string;
\}
\end{DoxyCode}
\hypertarget{simple__prefix__impl_8h_a1d974ca63f3322d8a7d444c6ebbf6212}{\index{simple\-\_\-prefix\-\_\-impl.\-h@{simple\-\_\-prefix\-\_\-impl.\-h}!simple\-\_\-prefix\-\_\-encode@{simple\-\_\-prefix\-\_\-encode}}
\index{simple\-\_\-prefix\-\_\-encode@{simple\-\_\-prefix\-\_\-encode}!simple_prefix_impl.h@{simple\-\_\-prefix\-\_\-impl.\-h}}
\subsubsection[{simple\-\_\-prefix\-\_\-encode}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ simple\-\_\-prefix\-\_\-encode (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{msg, }
\item[{int}]{size\-\_\-of\-\_\-msg}
\end{DoxyParamCaption}
)}}\label{simple__prefix__impl_8h_a1d974ca63f3322d8a7d444c6ebbf6212}


encode a string based on the current \hyperlink{structsimple__prefix}{simple\-\_\-prefix} tree, size\-\_\-of\-\_\-msgs(param 2) should be specified in bytes\par
 {\bfseries Precondition \-:} The string into which the returned value should be captured should not have already been allocated. Right now, the function can only encode characters defined in L\-O\-W\-E\-R\-\_\-\-C\-A\-S\-E\-\_\-\-A\-L\-P\-H\-A\-B\-E\-T\-S macro\par
 {\bfseries Postcondition \-:} The message is encoded according to the \hyperlink{structsimple__prefix}{simple\-\_\-prefix} algorithm and returned to the calling environment 


\begin{DoxyParams}{Parameters}
{\em msg} & the string that needs to be encoded \\
\hline
{\em size\-\_\-of\-\_\-msg} & the length of the message \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the encoded message. \par
 The returned encoded message is not in binary, it is still a character array. It can be converted into binary using \hyperlink{simple__prefix__impl_8c_ac7b35ccc6d71b9a01d2ab3609e20e698}{char2bits(char $\ast$, int)} function 
\end{DoxyReturn}

\begin{DoxyCode}
\{
    \textcolor{keywordtype}{char} conversion\_tree[][27] = \{
        \textcolor{stringliteral}{"1"}, \textcolor{comment}{//e}
        \textcolor{stringliteral}{"01"}, \textcolor{comment}{//a}
        \textcolor{stringliteral}{"001"}, \textcolor{comment}{//r}
        \textcolor{stringliteral}{"0001"}, \textcolor{comment}{//i}
        \textcolor{stringliteral}{"00001"}, \textcolor{comment}{//o}
        \textcolor{stringliteral}{"000001"}, \textcolor{comment}{//t}
        \textcolor{stringliteral}{"0000001"}, \textcolor{comment}{//n}
        \textcolor{stringliteral}{"00000001"}, \textcolor{comment}{//s}
        \textcolor{stringliteral}{"000000001"}, \textcolor{comment}{//l}
        \textcolor{stringliteral}{"0000000001"}, \textcolor{comment}{//c}
        \textcolor{stringliteral}{"00000000001"}, \textcolor{comment}{//u}
        \textcolor{stringliteral}{"000000000001"}, \textcolor{comment}{//d}
        \textcolor{stringliteral}{"0000000000001"}, \textcolor{comment}{//p}
        \textcolor{stringliteral}{"00000000000001"}, \textcolor{comment}{//m}
        \textcolor{stringliteral}{"000000000000001"}, \textcolor{comment}{//h}
        \textcolor{stringliteral}{"0000000000000001"}, \textcolor{comment}{//g}
        \textcolor{stringliteral}{"00000000000000001"}, \textcolor{comment}{//b}
        \textcolor{stringliteral}{"000000000000000001"}, \textcolor{comment}{//f}
        \textcolor{stringliteral}{"0000000000000000001"}, \textcolor{comment}{//y}
        \textcolor{stringliteral}{"00000000000000000001"}, \textcolor{comment}{//w}
        \textcolor{stringliteral}{"000000000000000000001"}, \textcolor{comment}{//k}
        \textcolor{stringliteral}{"0000000000000000000001"}, \textcolor{comment}{//v}
        \textcolor{stringliteral}{"00000000000000000000001"}, \textcolor{comment}{//x}
        \textcolor{stringliteral}{"000000000000000000000001"}, \textcolor{comment}{//z}
        \textcolor{stringliteral}{"0000000000000000000000001"}, \textcolor{comment}{//j}
        \textcolor{stringliteral}{"00000000000000000000000001"}, \textcolor{comment}{//q}
        \textcolor{stringliteral}{"00000000000000000000000000"} \textcolor{comment}{//WHITE SPACE}
    \};
    \textcolor{keywordtype}{char} *encoded\_string = (\textcolor{keywordtype}{char} *)malloc(27*size\_of\_msg);
    \textcolor{keywordtype}{int} i = 0;
    \textcolor{keywordtype}{char} reference\_string[] = \hyperlink{simple__prefix__impl_8h_a94747a3d988297667d1f086be19a7f3d}{LOWER\_CASE\_ALPHABETS};
    \textcolor{keywordflow}{while} (i < size\_of\_msg) 
    \{
    \textcolor{comment}{//ignore un-recognized characters}
    \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})((strchr(reference\_string,\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg}[i])) - reference\_string) < 0 || (
      int)((strchr(reference\_string,\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg}[i])) - reference\_string) > 26) \{
        i++;
        \textcolor{keywordflow}{continue};
    \}
    encoded\_string = strcat(encoded\_string,conversion\_tree[(\textcolor{keywordtype}{int})((strchr(
      reference\_string,\hyperlink{structnode_ad80e777cd260fdd5ca6ad3f25b5e76de}{msg}[i])) - reference\_string)]);
    i++;
    \}
    \textcolor{keywordflow}{return} encoded\_string;
\}
\end{DoxyCode}
